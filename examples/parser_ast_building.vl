// Parser/AST Building with Complex Nested Reference Preparation
// Demonstrates building Abstract Syntax Trees with cross-scope reference validity

data class Token(val type: Str, val value: Str, val position: Int)
data class ParseError(val message: Str, val position: Int)

// AST Node types with reference-containing structures
data class Identifier(val name: Str)
data class Literal(val value: Str, val type: Str)
data class BinaryOp(val left: Expression, val operator: Str, val right: Expression)
data class FunctionCall(val name: Str, val args: Array<Expression>)
data class Block(val statements: Array<Statement>)

// Expression types (recursive reference structures)
data class Expression(val kind: ExpressionKind)
data class ExpressionKind(val variant: Str, val data: Str) // Simplified union type

// Statement types
data class Assignment(val target: Str, val value: Expression)
data class Return(val value: Expression)
data class Statement(val kind: StatementKind)
data class StatementKind(val variant: Str, val target: Str) // Simplified union type

// Parser state with accumulated references
data class ParseState(val tokens: Array<Token>, val position: Int, val errors: Array<ParseError>)
data class ParseResult(val expression: Expression, val state: ParseState)

// ========= TOKEN STREAM PREPARATION =========

fun createToken(type: Str, value: Str, pos: Int): Token {
    // Prepare token with references valid in caller scope
    val type_ref = type.bumpRef()
    val value_ref = value.bumpRef()
    return Token(type = type_ref, value = value_ref, position = pos).bumpRef()
}

fun tokenizeInput(input: Str): Array<Token> {
    // Tokenize input preparing all token references for parser use
    val tokens = Array<Token>().bumpRef()
    val input_ref = input.bumpRef()
    
    // Simplified tokenization - prepare each token for caller
    val words = input_ref.split(" ")
    for i in range(0, words.length) {
        val word = words.get(i)
        if (word.startsWith("\"")) {
            val token = createToken("STRING", word, i)
            tokens.push(token)
        } else if (word.matches("[0-9]+")) {
            val token = createToken("NUMBER", word, i)
            tokens.push(token)
        } else if (word.matches("[a-zA-Z_][a-zA-Z0-9_]*")) {
            val token = createToken("IDENTIFIER", word, i)
            tokens.push(token)
        } else {
            val token = createToken("OPERATOR", word, i)
            tokens.push(token)
        }
    }
    
    return tokens
}

// ========= PARSER STATE MANAGEMENT =========

fun createParseState(tokens: Array<Token>): ParseState {
    // Create initial parse state with prepared references
    val errors = Array<ParseError>().bumpRef()
    return ParseState(tokens = tokens, position = 0, errors = errors).bumpRef()
}

fun advanceParseState(state: ParseState): ParseState {
    // Advance parser state preparing new state for caller
    val new_pos = state.position + 1
    return ParseState(tokens = state.tokens, position = new_pos, errors = state.errors).bumpRef()
}

fun addParseError(state: ParseState, message: Str): ParseState {
    // Add error to state, preparing updated state for caller
    val error_msg = message.bumpRef()
    val error = ParseError(message = error_msg, position = state.position).bumpRef()
    val updated_errors = Array<ParseError>().bumpRef()
    
    // Copy existing errors and add new one
    for existing_error in state.errors {
        updated_errors.push(existing_error)
    }
    updated_errors.push(error)
    
    return ParseState(tokens = state.tokens, position = state.position, errors = updated_errors).bumpRef()
}

// ========= EXPRESSION PARSING WITH RECURSIVE REFERENCE PREPARATION =========

fun parseIdentifier(state: ParseState): ParseResult {
    // Parse identifier preparing AST node with references for caller
    if (state.position >= state.tokens.length) {
        val error_state = addParseError(state.ref(), "Unexpected end of input")
        val dummy_expr = createDummyExpression()
        return ParseResult(expression = dummy_expr, state = error_state).bumpRef()
    }
    
    val token = state.tokens.get(state.position)
    if (token.type != "IDENTIFIER") {
        val error_msg = "Expected identifier".bumpRef()
        val error_state = addParseError(state.ref(), error_msg)
        val dummy_expr = createDummyExpression()
        return ParseResult(expression = dummy_expr, state = error_state).bumpRef()
    }
    
    // Prepare identifier expression for caller
    val name_ref = token.value.bumpRef()
    val identifier = Identifier(name = name_ref).bumpRef()
    val expr_kind = ExpressionKind(variant = "identifier", data = name_ref).bumpRef()
    val expression = Expression(kind = expr_kind).bumpRef()
    
    val new_state = advanceParseState(state.ref())
    return ParseResult(expression = expression, state = new_state).bumpRef()
}

fun parseLiteral(state: ParseState): ParseResult {
    // Parse literal preparing AST node with references for caller
    val token = state.tokens.get(state.position)
    val value_ref = token.value.bumpRef()
    val type_ref = token.type.bumpRef()
    
    val literal = Literal(value = value_ref, type = type_ref).bumpRef()
    val expr_kind = ExpressionKind(variant = "literal", data = value_ref).bumpRef()
    val expression = Expression(kind = expr_kind).bumpRef()
    
    val new_state = advanceParseState(state.ref())
    return ParseResult(expression = expression, state = new_state).bumpRef()
}

fun parseBinaryOperation(left_result: ParseResult): ParseResult {
    // Parse binary operation combining prepared expressions
    val state = left_result.state
    
    if (state.position >= state.tokens.length) {
        return left_result  // No operator, return left side
    }
    
    val op_token = state.tokens.get(state.position)
    if (op_token.type != "OPERATOR") {
        return left_result  // No operator, return left side
    }
    
    val op_state = advanceParseState(state.ref())
    val right_result = parseExpression(op_state.ref())  // Recursive parsing
    
    // Prepare binary operation with references from both sides
    val operator_ref = op_token.value.bumpRef()
    val binary_op = BinaryOp(
        left = left_result.expression, 
        operator = operator_ref, 
        right = right_result.expression
    ).bumpRef()
    
    val expr_kind = ExpressionKind(variant = "binary_op", data = operator_ref).bumpRef()
    val expression = Expression(kind = expr_kind).bumpRef()
    
    return ParseResult(expression = expression, state = right_result.state).bumpRef()
}

fun parseExpression(state: ParseState): ParseResult {
    // Main expression parser with recursive reference preparation
    if (state.position >= state.tokens.length) {
        val error_state = addParseError(state.ref(), "Unexpected end of input")
        val dummy_expr = createDummyExpression()
        return ParseResult(expression = dummy_expr, state = error_state).bumpRef()
    }
    
    val token = state.tokens.get(state.position)
    
    // Parse primary expression based on token type
    val primary_result = if (token.type == "IDENTIFIER") {
        parseIdentifier(state.ref())
    } else if (token.type == "STRING" || token.type == "NUMBER") {
        parseLiteral(state.ref())
    } else {
        val error_state = addParseError(state.ref(), "Unexpected token")
        val dummy_expr = createDummyExpression()
        ParseResult(expression = dummy_expr, state = error_state).bumpRef()
    }
    
    // Check for binary operations (left-associative parsing)
    return parseBinaryOperation(primary_result.ref())
}

// ========= STATEMENT PARSING WITH COMPLEX NESTING =========

fun parseAssignment(state: ParseState): ParseResult {
    // Parse assignment statement preparing references for caller
    val target_result = parseIdentifier(state.ref())
    
    if (target_result.state.position >= target_result.state.tokens.length) {
        val error_state = addParseError(target_result.state.ref(), "Expected assignment operator")
        return ParseResult(expression = target_result.expression, state = error_state).bumpRef()
    }
    
    val equals_token = target_result.state.tokens.get(target_result.state.position)
    if (equals_token.value != "=") {
        val error_state = addParseError(target_result.state.ref(), "Expected =")
        return ParseResult(expression = target_result.expression, state = error_state).bumpRef()
    }
    
    val after_equals = advanceParseState(target_result.state.ref())
    val value_result = parseExpression(after_equals.ref())
    
    // Prepare assignment statement with prepared references
    val target_name = target_result.expression.kind.data.bumpRef()
    val assignment = Assignment(target = target_name, value = value_result.expression).bumpRef()
    val stmt_kind = StatementKind(variant = "assignment", target = target_name).bumpRef()
    val statement = Statement(kind = stmt_kind).bumpRef()
    
    // Convert statement to expression for return (simplified)
    val expr_kind = ExpressionKind(variant = "statement", data = target_name).bumpRef()
    val expression = Expression(kind = expr_kind).bumpRef()
    
    return ParseResult(expression = expression, state = value_result.state).bumpRef()
}

fun parseBlock(state: ParseState): ParseResult {
    // Parse block of statements preparing nested structure for caller
    val statements = Array<Statement>().bumpRef()
    val current_state = state.ref()
    
    // Parse multiple statements, each preparing references for our scope
    while (current_state.position < current_state.tokens.length) {
        val stmt_result = parseStatement(current_state.ref())
        
        // Extract statement from expression result (simplified)
        val stmt_kind = StatementKind(variant = "parsed", target = "statement").bumpRef()
        val statement = Statement(kind = stmt_kind).bumpRef()
        statements.push(statement)
        
        current_state = stmt_result.state.ref()
        
        // Break if we hit end or error
        if (stmt_result.state.errors.length > state.errors.length) {
            break
        }
    }
    
    // Prepare block with all collected statements
    val block = Block(statements = statements).bumpRef()
    val expr_kind = ExpressionKind(variant = "block", data = "block").bumpRef()
    val expression = Expression(kind = expr_kind).bumpRef()
    
    return ParseResult(expression = expression, state = current_state).bumpRef()
}

fun parseStatement(state: ParseState): ParseResult {
    // Dispatch statement parsing preparing appropriate AST for caller
    if (state.position >= state.tokens.length) {
        val error_state = addParseError(state.ref(), "Unexpected end of input")
        val dummy_expr = createDummyExpression()
        return ParseResult(expression = dummy_expr, state = error_state).bumpRef()
    }
    
    // Look ahead to determine statement type
    val token = state.tokens.get(state.position)
    val next_pos = state.position + 1
    
    if (next_pos < state.tokens.length) {
        val next_token = state.tokens.get(next_pos)
        if (next_token.value == "=") {
            return parseAssignment(state.ref())
        }
    }
    
    // Default to expression statement
    return parseExpression(state.ref())
}

// ========= HELPER FUNCTIONS =========

fun createDummyExpression(): Expression {
    // Create dummy expression for error cases
    val dummy_data = "error".bumpRef()
    val expr_kind = ExpressionKind(variant = "error", data = dummy_data).bumpRef()
    return Expression(kind = expr_kind).bumpRef()
}

// ========= FULL PARSING PIPELINE =========

fun parseProgram(input: Str): ParseResult {
    // Complete parsing pipeline preparing full AST for caller
    val tokens = tokenizeInput(input.ref())
    val initial_state = createParseState(tokens.ref())
    val result = parseBlock(initial_state.ref())
    
    return result
}

fun main() {
    // Test parser with various inputs
    val simple_input = "x = 42"
    val complex_input = "result = foo + bar * baz"
    val multi_statement = "x = 1 y = x + 2"
    
    // Parse different complexity levels
    val simple_ast = parseProgram(simple_input.bumpRef())
    val complex_ast = parseProgram(complex_input.bumpRef())
    val multi_ast = parseProgram(multi_statement.bumpRef())
    
    // All AST references are prepared and valid for use
    println("Simple parse complete, errors: {}", simple_ast.state.errors.length)
    println("Complex parse complete, errors: {}", complex_ast.state.errors.length)
    println("Multi-statement parse complete, errors: {}", multi_ast.state.errors.length)
    
    // Demonstrate deep access to nested prepared references
    println("Simple AST kind: {}", simple_ast.expression.kind.variant)
    println("Complex AST kind: {}", complex_ast.expression.kind.variant)
    
    // Show error handling preserves references
    val invalid_input = "invalid syntax here"
    val error_ast = parseProgram(invalid_input.bumpRef())
    println("Error parse complete, errors: {}", error_ast.state.errors.length)
    
    if (error_ast.state.errors.length > 0) {
        val first_error = error_ast.state.errors.get(0)
        println("First error: {} at position {}", first_error.message, first_error.position)
    }
}

// PARSER/AST BUILDING REFERENCE PREPARATION:
//
// This demonstrates sophisticated parsing patterns where reference preparation enables:
//
// 1. TOKEN STREAM PREPARATION:
//    - tokenizeInput: Creates array of tokens with prepared string references
//    - createToken: Prepares individual tokens for parser consumption
//    - All token references remain valid throughout parsing process
//
// 2. RECURSIVE DESCENT PARSING:
//    - parseExpression, parseBinaryOperation: Recursive calls building nested AST
//    - Each parsing level prepares references for caller's AST construction
//    - Binary operations combine prepared left/right expression references
//
// 3. STATE ACCUMULATION:
//    - ParseState tracks position and errors with prepared reference arrays
//    - addParseError, advanceParseState: Prepare updated states for caller
//    - Error messages prepared as references for caller error handling
//
// 4. COMPLEX AST CONSTRUCTION:
//    - Expression/Statement types contain recursive reference structures
//    - parseBlock: Builds arrays of statements with prepared references
//    - Nested structures maintain reference validity across parsing levels
//
// 5. ERROR HANDLING PRESERVATION:
//    - Parse errors contain prepared message references
//    - Error states preserve reference validity for error reporting
//    - Recovery parsing maintains prepared references in error paths
//
// 6. PIPELINE COMPOSITION:
//    - parseProgram: Combines tokenization -> state creation -> parsing
//    - Each stage prepares references for subsequent stages
//    - Final AST contains references prepared across entire pipeline
//
// KEY ADVANCEMENT: Parser demonstrates how reference preparation enables
// building complex nested data structures (ASTs) where all string content,
// error messages, and structural references remain valid for the caller,
// regardless of parsing complexity or error conditions.