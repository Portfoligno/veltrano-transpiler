// Advanced Tree/Graph Structure with Recursive Reference Preparation
// Demonstrates complex data structure building with cross-scope reference validity

data class TreeNode(val value: Str, val children: Array<TreeNode>)
data class GraphNode(val id: Str, val connections: Array<Str>)
data class ProcessingContext(val depth: Int, val path: Array<Str>)

// ========= RECURSIVE TREE CONSTRUCTION =========

fun createLeafNode(value: Str): TreeNode {
    // Prepare leaf node with reference that outlives function
    val value_ref = value.bumpRef()
    val empty_children = Array<TreeNode>().bumpRef()
    return TreeNode(value = value_ref, children = empty_children).bumpRef()
}

fun buildSubtree(root_value: Str, child_values: Array<Str>): TreeNode {
    // Recursively prepare all child nodes for caller scope
    val prepared_children = Array<TreeNode>().bumpRef()
    
    // Each child preparation involves recursive reference preparation
    for child_val in child_values {
        val child_node = createLeafNode(child_val)
        prepared_children.push(child_node)
    }
    
    val root_value_ref = root_value.bumpRef()
    return TreeNode(value = root_value_ref, children = prepared_children).bumpRef()
}

fun buildComplexTree(spec: Array<Array<Str>>): TreeNode {
    // Build tree from specification where each array represents a level
    val root_spec = spec.get(0)
    val child_specs = spec.slice(1, spec.length)
    
    if (child_specs.length == 0) {
        // Base case: single level tree
        return buildSubtree(root_spec.get(0), root_spec.slice(1, root_spec.length))
    } else {
        // Recursive case: build subtrees and connect them
        val root_value = root_spec.get(0).bumpRef()
        val subtree_children = Array<TreeNode>().bumpRef()
        
        // Each recursive call prepares references for our scope
        for child_spec in child_specs {
            val subtree = buildComplexTree(Array<Array<Str>>().push(child_spec).bumpRef())
            subtree_children.push(subtree)
        }
        
        return TreeNode(value = root_value, children = subtree_children).bumpRef()
    }
}

// ========= GRAPH STRUCTURE WITH CIRCULAR REFERENCES =========

fun createGraphNodes(node_specs: Array<Array<Str>>): Array<GraphNode> {
    // Build graph nodes where each spec is [id, connection1, connection2, ...]
    val prepared_nodes = Array<GraphNode>().bumpRef()
    
    for spec in node_specs {
        val node_id = spec.get(0).bumpRef()
        val connections = Array<Str>().bumpRef()
        
        // Prepare all connection references for caller scope
        for i in range(1, spec.length) {
            val connection_ref = spec.get(i).bumpRef()
            connections.push(connection_ref)
        }
        
        val node = GraphNode(id = node_id, connections = connections).bumpRef()
        prepared_nodes.push(node)
    }
    
    return prepared_nodes
}

fun buildGraphWithValidation(specs: Array<Array<Str>>): Array<GraphNode> {
    // Build graph with reference validation across multiple phases
    val initial_nodes = createGraphNodes(specs)
    val validated_nodes = Array<GraphNode>().bumpRef()
    
    // Validation phase prepares filtered results
    for node in initial_nodes {
        if (node.connections.length > 0) {
            // Only include nodes with connections, but prepare for caller
            validated_nodes.push(node)
        }
    }
    
    return validated_nodes
}

// ========= CONTEXT-AWARE TREE PROCESSING =========

fun processNodeWithContext(node: TreeNode, context: ProcessingContext): ProcessingContext {
    // Process node and prepare enhanced context for caller
    val new_depth = context.depth + 1
    val extended_path = Array<Str>().bumpRef()
    
    // Copy existing path references and add current node
    for path_element in context.path {
        extended_path.push(path_element)
    }
    extended_path.push(node.value)
    
    return ProcessingContext(depth = new_depth, path = extended_path).bumpRef()
}

fun traverseTreeWithContexts(root: TreeNode): Array<ProcessingContext> {
    // Traverse tree collecting contexts prepared for caller scope
    val contexts = Array<ProcessingContext>().bumpRef()
    val initial_path = Array<Str>().bumpRef()
    val root_context = ProcessingContext(depth = 0, path = initial_path).bumpRef()
    
    // Process root
    val processed_context = processNodeWithContext(root.ref(), root_context.ref())
    contexts.push(processed_context)
    
    // Recursively process children, each preparing contexts for our scope
    for child in root.children {
        val child_contexts = traverseTreeWithContexts(child.ref())
        for ctx in child_contexts {
            // Each context has references prepared by recursive calls
            contexts.push(ctx)
        }
    }
    
    return contexts
}

// ========= COMPLEX TREE TRANSFORMATION =========

fun transformTreeValues(tree: TreeNode, transform_fn: Fun<Str, Str>): TreeNode {
    // Transform tree preparing new references for caller scope
    val transformed_value = transform_fn(tree.value).bumpRef()
    val transformed_children = Array<TreeNode>().bumpRef()
    
    // Recursively transform children, each preparing references for our scope
    for child in tree.children {
        val transformed_child = transformTreeValues(child.ref(), transform_fn)
        transformed_children.push(transformed_child)
    }
    
    return TreeNode(value = transformed_value, children = transformed_children).bumpRef()
}

fun createTreeFactory(base_values: Array<Str>): Fun<Int, TreeNode> {
    // Factory function preparing tree builders for caller scope
    val prepared_values = Array<Str>().bumpRef()
    for val in base_values {
        prepared_values.push(val.bumpRef())
    }
    
    // Return function that creates trees with prepared references
    return |depth: Int| -> TreeNode {
        if (depth <= 0) {
            return createLeafNode(prepared_values.get(0))
        } else {
            val children = Array<TreeNode>().bumpRef()
            for i in range(1, min(prepared_values.length, depth + 1)) {
                val child_factory = createTreeFactory(prepared_values.slice(i, prepared_values.length))
                val child = child_factory(depth - 1)
                children.push(child)
            }
            val root_value = prepared_values.get(0)
            return TreeNode(value = root_value, children = children).bumpRef()
        }
    }
}

fun main() {
    // ========= BASIC TREE CONSTRUCTION =========
    val simple_tree = buildSubtree("root", Array<Str>().push("child1").push("child2").push("child3"))
    
    // ========= COMPLEX NESTED TREE =========
    val tree_spec = Array<Array<Str>>()
        .push(Array<Str>().push("level0"))
        .push(Array<Str>().push("level1a").push("level1b"))
        .push(Array<Str>().push("level2a").push("level2b").push("level2c"))
    val complex_tree = buildComplexTree(tree_spec.bumpRef())
    
    // ========= GRAPH CONSTRUCTION =========
    val graph_specs = Array<Array<Str>>()
        .push(Array<Str>().push("node1").push("node2").push("node3"))
        .push(Array<Str>().push("node2").push("node1").push("node4"))
        .push(Array<Str>().push("node3").push("node1"))
        .push(Array<Str>().push("node4").push("node2"))
    val graph_nodes = buildGraphWithValidation(graph_specs.bumpRef())
    
    // ========= CONTEXT-AWARE PROCESSING =========
    val traversal_contexts = traverseTreeWithContexts(simple_tree.ref())
    
    // ========= TREE TRANSFORMATION =========
    val uppercase_transform = |s: Str| -> Str { s.toUpperCase() }
    val transformed_tree = transformTreeValues(complex_tree.ref(), uppercase_transform)
    
    // ========= FACTORY PATTERN =========
    val factory_values = Array<Str>().push("factory").push("generated").push("nodes")
    val tree_factory = createTreeFactory(factory_values.bumpRef())
    val generated_tree = tree_factory(2)
    
    // All references are prepared and valid for use here
    println("Simple tree root: {}, children: {}", simple_tree.value, simple_tree.children.length)
    println("Complex tree value: {}", complex_tree.value)
    println("Graph nodes: {}", graph_nodes.length)
    println("Traversal contexts: {}", traversal_contexts.length)
    println("Transformed tree root: {}", transformed_tree.value)
    println("Generated tree root: {}", generated_tree.value)
    
    // Demonstrate deep access to prepared references
    if (complex_tree.children.length > 0) {
        val first_child = complex_tree.children.get(0)
        println("First child value: {}", first_child.value)
    }
    
    if (traversal_contexts.length > 0) {
        val first_context = traversal_contexts.get(0)
        println("First context depth: {}, path length: {}", first_context.depth, first_context.path.length)
    }
}

// ADVANCED TREE/GRAPH REFERENCE PREPARATION:
//
// This demonstrates sophisticated patterns where reference preparation enables:
//
// 1. RECURSIVE CONSTRUCTION:
//    - buildSubtree, buildComplexTree: Recursive calls each preparing references for caller
//    - createLeafNode: Base case that prepares terminal references
//    - Reference preparation propagates up through recursion levels
//
// 2. CIRCULAR REFERENCE HANDLING:
//    - createGraphNodes, buildGraphWithValidation: Build interconnected structures
//    - Each node's connections array contains prepared string references
//    - Graph validation prepares filtered results for caller use
//
// 3. CONTEXT PROPAGATION:
//    - processNodeWithContext, traverseTreeWithContexts: Build contexts with accumulated state
//    - Each context contains path arrays with prepared string references
//    - Context building preserves reference validity across traversal
//
// 4. FUNCTIONAL TRANSFORMATION:
//    - transformTreeValues: Recursively transform while preparing new references
//    - createTreeFactory: Higher-order function returning tree builders
//    - Factory closure captures prepared references for later use
//
// 5. DEEP REFERENCE CHAINS:
//    - Tree nodes contain arrays of other tree nodes (recursive reference structure)
//    - Graph nodes reference other nodes by ID (cross-reference patterns)
//    - Processing contexts accumulate reference chains through traversal
//
// KEY ADVANCEMENT: These patterns show reference preparation enabling complex
// data structure manipulation where references remain valid across multiple
// levels of function calls, recursive construction, and deferred execution.